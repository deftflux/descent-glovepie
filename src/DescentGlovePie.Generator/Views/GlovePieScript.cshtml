@using System
@using System.Collections.Generic
@using System.Linq;
@using iSynaptic.Commons;
@using DescentGlovePie.Generator;
@inherits RazorEngine.Templating.TemplateBase<MapInfo>
/* @Model.FileName
GlovePIE script generated by descent-glovepie
Apache License 2.0
Project Home: https://github.com/deftflux/descent-glovepie
@if (Model.Comments != null)
{
<text>
@Model.Comments
</text>
}
*/

@{
    var inputPrefix = Model.Map.InputPrefix ?? "";
    if (inputPrefix.Length > 0)
    {
        inputPrefix += ".";
    }

    var shiftButtons = Model.Map.ShiftButtons.ToMaybe().Select(s => s.ToList()).ValueOrDefault(() => new List<string>());
    var nonShiftButtons = Model.Map.ButtonMappings.Select(m => m.Input)
                               .Concat(Model.Map.ThrottleMapping.ToMaybe().Select(t => new[] {t.ForwardDigitalInput ?? t.ForwardAnalogInput, t.ReverseDigitalInput ?? t.ReverseAnalogInput}).ValueOrDefault(() => new string[0]))
                               .Distinct()
                               .Except(shiftButtons)
                               .ToList();
    var allButtons = nonShiftButtons.Concat(shiftButtons).ToList();

    const int buttonStateOff = 0;
    const int buttonStateNormal = 1;
    const int buttonStateCompleted = -1;
    var buttonStateShift = new Dictionary<string, int>();
    for (int i = 0; i < shiftButtons.Count; i++)
    {
        buttonStateShift[shiftButtons[i]] = i + 2;
    }

    Func<string, string> getNormalButtonCondition = (string button) =>
    {
        var shiftButtonsAsNormal = shiftButtons.Except(Model.Map.ButtonMappings.Where(m => m.Input == button).SelectMany(m => m.ShiftMappings.Select(s => s.ShiftInput))).ToList();
        var buttonCondition = (shiftButtonsAsNormal.Count == 0)
            ? ("(var.ButtonState" + button + " == " + buttonStateNormal + ")")
            : ("InSet(var.ButtonState" + button + ", " + buttonStateNormal + ", " + String.Join(", ", shiftButtonsAsNormal.Select(b => buttonStateShift[b])) + ")");
        return buttonCondition;
    };
}
@helper KeyboardMacro(KeyboardMacroOutput macro)
{
    foreach (var keystroke in macro.Outputs)
    {
        foreach (var key in keystroke)
        {
            @:Keyboard.@(key) := true;
        }
        foreach (var key in keystroke.Reverse())
        {
            @:Keyboard.@(key) := false;
        }
    }
}

// Initial var states:
if (not var.Initialized) {
    @foreach (var button in allButtons)
    {
        @:var.ButtonState@(button) := @(buttonStateOff);
    }
    
    var.ShiftState := @(buttonStateNormal);
    var.ShiftDefault := false;

    var.Initialized := true;
}


// Axis mappings:
@foreach (var axisMapping in Model.Map.AxisMappings)
{
    @:@(axisMapping.Output) := @(axisMapping.Invert ? "-" : "")@(inputPrefix)@(axisMapping.Input);
}


// When shift buttons pressed:
@foreach (var shiftButton in shiftButtons)
{
<text>
    // @(shiftButton)
    if (@(inputPrefix)@(shiftButton) and var.ButtonState@(shiftButton) == @(buttonStateOff)) {
        if (var.ShiftState == 1) {
            var.ShiftState := @(buttonStateShift[shiftButton]);
            var.ShiftDefault := true;
        } else {
            var.ShiftDefault := false;
        }
        var.ButtonState@(shiftButton) := var.ShiftState;
    }
</text>
}


// When non-shift buttons pressed:
@foreach (var button in nonShiftButtons)
{
<text>
    // @(button)
    if (@(inputPrefix)@(button) and var.ButtonState@(button) == @(buttonStateOff)) {
        var.ButtonState@(button) := var.ShiftState;
        var.ShiftDefault := false;
    }
</text>
}


// Normal button mappings:
@foreach (var mapping in Model.Map.ButtonMappings.Where(m => m.NormalOutput != null && !shiftButtons.Contains(m.Input)))
{
    var buttonCondition = getNormalButtonCondition(mapping.Input);
    if (mapping.NormalOutput is BasicMappingOutput)
    {
        var basicOutput = (BasicMappingOutput) mapping.NormalOutput;
        @:@(basicOutput.Output) := @(buttonCondition);
    }
    else if (mapping.NormalOutput is KeyboardMacroOutput)
    {
        var macroOutput = (KeyboardMacroOutput) mapping.NormalOutput;
        <text>
            if (@(buttonCondition)) {
                var.ButtonState@(mapping.Input) := @(buttonStateCompleted);
                @(KeyboardMacro(macroOutput))
            }
        </text>
    }
    else 
    {
        throw new ApplicationException(String.Format("Unsupported MappingOutput type {0}.", mapping.NormalOutput.GetType()));
    }
}


@if (Model.Map.ThrottleMapping != null)
{
    @:// Throttle mapping:
    var mapping = Model.Map.ThrottleMapping;
    string analogThreshold = mapping.AnalogThreshold.GetValueOrDefault(0.1).ToString();
    var forwardCondition = (mapping.ForwardDigitalInput != null)
        ? getNormalButtonCondition(mapping.ForwardDigitalInput)
        : ("(" + inputPrefix + mapping.ForwardAnalogInput + " > " + analogThreshold + ")");
    var reverseCondition = (mapping.ReverseDigitalInput != null)
        ? getNormalButtonCondition(mapping.ReverseDigitalInput)
        : ("(" + inputPrefix + mapping.ReverseAnalogInput + " > " + analogThreshold + ")");
    var forwardInput = (mapping.ForwardAnalogInput != null)
        ? inputPrefix + mapping.ForwardAnalogInput
        : "1";
    var reverseInput = (mapping.ReverseAnalogInput != null)
        ? inputPrefix + mapping.ReverseAnalogInput
        : "1";
    @:@(mapping.AxisOutput) := ((-@(forwardInput) * @(forwardCondition)) + (@(reverseInput) * @(reverseCondition) * (not @(forwardCondition))));
    if (mapping.ButtonOutput != null)
    {
        @:@(mapping.ButtonOutput) := (@(forwardCondition) and @(reverseCondition));
    }
}


// Shifted button mappings:
@foreach (var shiftButton in shiftButtons)
{
    foreach (var buttonMapping in Model.Map.ButtonMappings)
    {
        foreach (var shiftMapping in buttonMapping.ShiftMappings.Where(s => s.ShiftInput == shiftButton))
        {
            @:// @(shiftButton)+@(buttonMapping.Input)
            if (shiftMapping.Output is BasicMappingOutput)
            {
                var basicOutput = (BasicMappingOutput) shiftMapping.Output;
                @:@(basicOutput.Output) := (var.ButtonState@(buttonMapping.Input) == @(buttonStateShift[shiftButton]));
            }
            else if (shiftMapping.Output is KeyboardMacroOutput)
            {
                var macroOutput = (KeyboardMacroOutput) shiftMapping.Output;
                <text>
                    if (var.ButtonState@(buttonMapping.Input) == @(buttonStateShift[shiftButton])) {
                        var.ButtonState@(buttonMapping.Input) := @(buttonStateCompleted);
                        @(KeyboardMacro(macroOutput))
                    }
                </text>
            }
            else 
            {
                throw new ApplicationException(String.Format("Unsupported MappingOutput type {0}.", shiftMapping.Output.GetType()));
            }
        }
    }
}


// When non-shift buttons released:
@foreach (var button in nonShiftButtons)
{
    @:if ((not @(inputPrefix)@(button)) and var.ButtonState@(button) != @(buttonStateOff)) var.ButtonState@(button) := @(buttonStateOff);
}


// When shift buttons released:
@foreach (var shiftButton in shiftButtons)
{
    var normalOutput = Model.Map.ButtonMappings.Where(m => m.Input == shiftButton).Select(m => m.NormalOutput).SingleOrDefault();
    <text>
        // @(shiftButton)
        if ((not @(inputPrefix)@(shiftButton)) and var.ButtonState@(shiftButton) != @(buttonStateOff)) {
            if (var.ShiftState == @(buttonStateShift[shiftButton])) {
                var.ShiftState := @(buttonStateNormal);
                @if (normalOutput != null)
                {
                    @:if (var.ShiftDefault) {
                    if (normalOutput is BasicMappingOutput)
                    {
                        var basicOutput = (BasicMappingOutput) normalOutput;
                        @:@(basicOutput.Output) := true;
                        @:@(basicOutput.Output) := false;
                    }
                    else if (normalOutput is KeyboardMacroOutput)
                    {
                        var macroOutput = (KeyboardMacroOutput) normalOutput;
                        @(KeyboardMacro(macroOutput))
                    }
                    else 
                    {
                        throw new ApplicationException(String.Format("Unsupported MappingOutput type {0}.", normalOutput.GetType()));
                    }
                    @:}
                }
            }
            var.ButtonState@(shiftButton) := @(buttonStateOff);
        }
    </text>
}


// Debug text:

if (var.PreviousShiftState != var.ShiftState) {
    if (var.ShiftState == @(buttonStateNormal)) debug := "No Shift";
    @foreach (var shiftButton in shiftButtons)
    {
        @:if (var.ShiftState == @(buttonStateShift[shiftButton])) debug := "Shift: @(shiftButton)";
    }
    var.PreviousShiftState := var.ShiftState;
}
