@using System
@using System.Collections.Generic
@using System.Linq;
@using iSynaptic.Commons;
@using DescentGlovePie.Generator;
@inherits RazorEngine.Templating.TemplateBase<MapInfo>
/* @Model.FileName
GlovePIE script generated by descent-glovepie
Apache License 2.0
Project Home: https://github.com/deftflux/descent-glovepie
@if (Model.Comments != null)
{
<text>
@Model.Comments
</text>
}
*/

@{
    var shiftButtons = Model.Map.ShiftButtons.ToMaybe().Select(s => s.ToList()).ValueOrDefault(() => new List<string>());
    var nonShiftButtons = Model.Map.ButtonMappings.Select(m => m.Input)
        .Concat(Model.Map.ThrottleMapping.ToMaybe().Select(t => new[] {t.ForwardDigitalInput ?? t.ForwardAnalogInput, t.ReverseDigitalInput ?? t.ReverseAnalogInput}).ValueOrDefault(() => new string[0]))
        .Distinct()
        .Except(shiftButtons)
        .ToList();
    var allButtons = nonShiftButtons.Concat(shiftButtons).ToList();

    var inputPrefix = Model.Map.InputPrefix ?? "";
    if (inputPrefix.Length > 0)
    {
        inputPrefix += ".";
    }

    var resolveLookup = new Dictionary<string, string>();   
    Func<string, string> resolveInput = (string input) =>
    {
        string result;
        if (!resolveLookup.TryGetValue(input, out result))
        {
            result = input;
            if (result.StartsWith(":"))
            {
                result = result.Substring(1);
            }
            else
            {
                result = Model.Map.InputAliases.ToMaybe()
                    .Select(l => l.FirstOrDefault(a => a.Name.Equals(result, StringComparison.OrdinalIgnoreCase)))
                    .Select(a => a.Value)
                    .ValueOrDefault(() => inputPrefix + result);
            }

            resolveLookup.Add(input, result);
        }
        return result;
    };
    
    var aliasLookup = new Dictionary<string, string>();
    foreach (var button in allButtons)
    {
        var alias = button;
        if (inputPrefix.Length > 0 && alias.StartsWith(":"))
        {
            if (alias.StartsWith(":" + inputPrefix, StringComparison.OrdinalIgnoreCase))
            {
                alias = alias.Substring(inputPrefix.Length + 1);
            }
        }

        alias = Model.Map.InputAliases.ToMaybe()
            .Select(l => l.FirstOrDefault(a => a.Value.Equals(alias, StringComparison.OrdinalIgnoreCase)))
            .Select(a => a.Name)
            .ValueOrDefault(alias);

        aliasLookup.Add(button, alias);
    }

    Func<string, string> aliasify = (string input) =>
    {
        return aliasLookup[input].Replace(":", "");
    };
    
    var idLookup = new Dictionary<string, string>();
    foreach (var button in allButtons)
    {
        var id = button;
        if (inputPrefix.Length > 0 && id.StartsWith(":"))
        {
            if (id.StartsWith(":" + inputPrefix, StringComparison.OrdinalIgnoreCase))
            {
                var shortId = id.Substring(inputPrefix.Length + 1);
                if (Model.Map.InputAliases.ToMaybe().Select(l => !l.Any(a => a.Name.Equals(shortId, StringComparison.OrdinalIgnoreCase))).ValueOrDefault(false))
                {
                    id = shortId;
                }
            }
        }

        id = id.Replace(':', '_').Replace('.', '_');
        
        idLookup.Add(button, id);
    }
    
    Func<string, string> toId = (string input) =>
    {
        return idLookup[input];
    };
    
    const int buttonStateOff = 0;
    const int buttonStateNormal = 1;
    const int buttonStateCompleted = -1;
    var buttonStateShift = new Dictionary<string, int>();
    for (int i = 0; i < shiftButtons.Count; i++)
    {
        buttonStateShift[shiftButtons[i]] = i + 2;
    }

    Func<string, string> getNormalButtonCondition = (string button) =>
    {
        var shiftButtonsAsNormal = shiftButtons.Except(Model.Map.ButtonMappings.Where(m => m.Input == button).SelectMany(m => m.ShiftMappings.Select(s => s.ShiftInput))).ToList();
        var buttonCondition = (shiftButtonsAsNormal.Count == 0)
            ? ("(var.ButtonState" + toId(button) + " == " + buttonStateNormal + ")")
            : ("InSet(var.ButtonState" + toId(button) + ", " + buttonStateNormal + ", " + String.Join(", ", shiftButtonsAsNormal.Select(b => buttonStateShift[b])) + ")");
        return buttonCondition;
    };
}
@helper KeyboardMacro(KeyboardMacroOutput macro)
{
    foreach (var keystroke in macro.Outputs)
    {
        foreach (var key in keystroke)
        {
            @:Keyboard.@(key) := true;
        }
        foreach (var key in keystroke.Reverse())
        {
            @:Keyboard.@(key) := false;
        }
    }
}

// Initial var states:
if (not var.Initialized) {
    @foreach (var button in allButtons)
    {
        @:var.ButtonState@(toId(button)) := @(buttonStateOff);
    }
    
    var.ShiftState := @(buttonStateNormal);
    var.ShiftDefault := false;

    var.Initialized := true;
}


// Axis mappings:
@foreach (var axisMapping in Model.Map.AxisMappings)
{
    @:@(axisMapping.Output) := @(axisMapping.Invert ? "-" : "")@(resolveInput(axisMapping.Input));
}


// When shift buttons pressed:
@foreach (var shiftButton in shiftButtons)
{
<text>
    // @(aliasify(shiftButton))
    if (@(resolveInput(shiftButton)) and var.ButtonState@(toId(shiftButton)) == @(buttonStateOff)) {
        if (var.ShiftState == 1) {
            var.ShiftState := @(buttonStateShift[shiftButton]);
            var.ShiftDefault := true;
        }
        var.ButtonState@(toId(shiftButton)) := var.ShiftState;
    }
</text>
}


// When non-shift buttons pressed:
@foreach (var button in nonShiftButtons)
{
<text>
    // @(aliasify(button))
    if (@(resolveInput(button)) and var.ButtonState@(toId(button)) == @(buttonStateOff)) {
        var.ButtonState@(toId(button)) := var.ShiftState;
    }
</text>
}


// Normal button mappings:
@foreach (var mapping in Model.Map.ButtonMappings.Where(m => m.NormalOutput != null && !shiftButtons.Contains(m.Input)))
{
    var buttonCondition = getNormalButtonCondition(mapping.Input);
    if (mapping.NormalOutput is BasicMappingOutput)
    {
        var basicOutput = (BasicMappingOutput) mapping.NormalOutput;
        @:@(basicOutput.Output) := @(buttonCondition);
    }
    else if (mapping.NormalOutput is KeyboardMacroOutput)
    {
        var macroOutput = (KeyboardMacroOutput) mapping.NormalOutput;
        <text>
            if (@(buttonCondition)) {
                var.ButtonState@(toId(mapping.Input)) := @(buttonStateCompleted);
                @(KeyboardMacro(macroOutput))
            }
        </text>
    }
    else 
    {
        throw new ApplicationException(String.Format("Unsupported MappingOutput type {0}.", mapping.NormalOutput.GetType()));
    }
}


@if (Model.Map.ThrottleMapping != null)
{
    @:// Throttle mapping:
    var mapping = Model.Map.ThrottleMapping;
    string analogThreshold = mapping.AnalogThreshold.GetValueOrDefault(0.1).ToString();
    var forwardCondition = (mapping.ForwardDigitalInput != null)
        ? getNormalButtonCondition(mapping.ForwardDigitalInput)
        : ("(" + resolveInput(mapping.ForwardAnalogInput) + " > " + analogThreshold + ")");
    var reverseCondition = (mapping.ReverseDigitalInput != null)
        ? getNormalButtonCondition(mapping.ReverseDigitalInput)
        : ("(" + resolveInput(mapping.ReverseAnalogInput) + " > " + analogThreshold + ")");
    var forwardInput = (mapping.ForwardAnalogInput != null)
        ? resolveInput(mapping.ForwardAnalogInput)
        : "1";
    var reverseInput = (mapping.ReverseAnalogInput != null)
        ? resolveInput(mapping.ReverseAnalogInput)
        : "1";
    @:@(mapping.AxisOutput) := ((-@(forwardInput) * @(forwardCondition)) + (@(reverseInput) * @(reverseCondition) * (not @(forwardCondition))));
    if (mapping.ButtonOutput != null)
    {
        @:@(mapping.ButtonOutput) := (@(forwardCondition) and @(reverseCondition));
    }
}


// Shifted button mappings:
@foreach (var shiftButton in shiftButtons)
{
    foreach (var buttonMapping in Model.Map.ButtonMappings)
    {
        foreach (var shiftMapping in buttonMapping.ShiftMappings.Where(s => s.ShiftInput == shiftButton))
        {
            @:// @(aliasify(shiftButton))+@(aliasify(buttonMapping.Input))
            if (shiftMapping.Output is BasicMappingOutput)
            {
                var basicOutput = (BasicMappingOutput) shiftMapping.Output;
                <text>
                    @(basicOutput.Output) := (var.ButtonState@(toId(buttonMapping.Input)) == @(buttonStateShift[shiftButton]));
                    if (var.ShiftDefault and (var.ButtonState@(toId(buttonMapping.Input)) == @(buttonStateShift[shiftButton])) {
                        var.ShiftDefault := true;
                    }
                </text>
            }
            else if (shiftMapping.Output is KeyboardMacroOutput)
            {
                var macroOutput = (KeyboardMacroOutput) shiftMapping.Output;
                <text>
                    if (var.ButtonState@(toId(buttonMapping.Input)) == @(buttonStateShift[shiftButton])) {
                        var.ButtonState@(toId(buttonMapping.Input)) := @(buttonStateCompleted);
                        var.ShiftDefault := false;
                        @(KeyboardMacro(macroOutput))
                    }
                </text>
            }
            else 
            {
                throw new ApplicationException(String.Format("Unsupported MappingOutput type {0}.", shiftMapping.Output.GetType()));
            }
        }
    }
}


// When non-shift buttons released:
@foreach (var button in nonShiftButtons)
{
    @:if ((not @(resolveInput(button))) and var.ButtonState@(toId(button)) != @(buttonStateOff)) var.ButtonState@(toId(button)) := @(buttonStateOff);
}


// When shift buttons released:
@foreach (var shiftButton in shiftButtons)
{
    var normalOutput = Model.Map.ButtonMappings.Where(m => m.Input == shiftButton).Select(m => m.NormalOutput).SingleOrDefault();
    <text>
        // @(aliasify(shiftButton))
        if ((not @(resolveInput(shiftButton))) and var.ButtonState@(toId(shiftButton)) != @(buttonStateOff)) {
            if (var.ShiftState == @(buttonStateShift[shiftButton])) {
                var.ShiftState := @(buttonStateNormal);
                @if (normalOutput != null)
                {
                    @:if (var.ShiftDefault) {
                    if (normalOutput is BasicMappingOutput)
                    {
                        var basicOutput = (BasicMappingOutput) normalOutput;
                        @:@(basicOutput.Output) := true;
                        @:@(basicOutput.Output) := false;
                    }
                    else if (normalOutput is KeyboardMacroOutput)
                    {
                        var macroOutput = (KeyboardMacroOutput) normalOutput;
                        @(KeyboardMacro(macroOutput))
                    }
                    else 
                    {
                        throw new ApplicationException(String.Format("Unsupported MappingOutput type {0}.", normalOutput.GetType()));
                    }
                    @:}
                }
            }
            var.ButtonState@(toId(shiftButton)) := @(buttonStateOff);
        }
    </text>
}


// Debug text:

if (var.PreviousShiftState != var.ShiftState) {
    if (var.ShiftState == @(buttonStateNormal)) debug := "No Shift";
    @foreach (var shiftButton in shiftButtons)
    {
        @:if (var.ShiftState == @(buttonStateShift[shiftButton])) debug := "Shift: @(shiftButton)";
    }
    var.PreviousShiftState := var.ShiftState;
}
